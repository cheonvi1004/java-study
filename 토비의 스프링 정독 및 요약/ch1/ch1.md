# 챕터1 오브젝트와 의존관계

노트의 목적은 최대한 핵심만 간추려 적는 것

재독을 위해 빠르게 살펴보기 위해서

대신 해당 페이지를 덧붙여 나중에 추가로 찾아볼 수 있게 하자



## 책 목록

- 리팩토링(마틴파울러)
- GoF의 디자인 패턴(에릭 감마 외)
- 헤드 퍼스트 디자인 패턴(에릭 프리먼)



55p

- 자바빈(빈)
    - 디폴트 생성자 : 파라미터가 없는 생성자, 리플렉션을 이용해 오브젝트를 생성할 때 필요하기 때문
    - 프로퍼티 : 자바빈이 노출하는 이름을 가진 속성, set/get메소드로 수정 또는 조회할 수 있는 필드


60p

## 관심사의 분리(Separation of Concerns)

- 변화

    객체지향의 세계에서는 모든 것이 변한다. 오브젝트에 대한 설계와 이를 구현한 코드가 변한다.그래서 개발자가 객체를 설계할 때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비할 것인가이다.

- 절차지향 VS 객체지향

    객체지향이 절차지향에 비해 초기에 좀 더 많은, 번거로운 작업을 요구하는 이유는 객체지향 기술 자체가 지니는, 변화에 효과적으로 대처할 수 있다는 기술적인 특징 때문이다

- 변화 대응

    변화에 대응하기 위한 가장 좋은 방법은 변화의 폭을 최소한으로 줄이는 것이다

    어떻게 변경이 일어날 때 필요한 작업을 최소화하고, 그 변경이 다른 곳에 문제를 일으키지 않게 할 수 있었을까? 그것은 `분리와 확장을 고려한 설계`가 있었기 때문이다


62p

어떻게 하면 나의 메소드/클래스에서 관심사를 분리할 수 있는가? 내가 만든 메소드를 분석해서 어떤 기능이 담겨있고 이렇게 묶어야 하는 이유를 메소드 주석으로 적어보자



64p

- 리팩토링

    기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다


67p

- 템플릿 메소드 패턴

    변하지 않는 기능은 슈퍼클래스에 만들어두고 자주 변경되며 확잘할 기능은 서브클래스에서 만들도록 하는 것

- 팩토리 메소드 패턴

    **서브클래스**에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것

    (팩토리 메소드 패턴은 템플릿 메소드 패턴을 포함하고 있다, '**서브클래스**'의 메소드로부터 객체를 생성하는 방법)


90p

- 컴포넌트

    **Object-oriented view**

    A component is viewed as a set of one or more cooperating classes. Each problem domain class (analysis) and infrastructure class (design) are explained to identify all attributes and operations that apply to its implementation. It also involves defining the interfaces that enable classes to communicate and cooperate.


92p

- IoC(Inversion of Control, 제어의 역전)

    프로그램 제어의 흐름 구조가 뒤바뀌는 것

    모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다. 모든 종류의 작업을 사용하는 쪽에서 제어하는 구조다

    제어의 역전이란 이런 제어 흐름의 개념을 꺼꾸로 뒤집는 것이다. 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 어디서 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다. 프로그램의 시작을 담당하는 main()과 같은 엔트리 포인트를 제외하면 모든 오브젝트는 이렇게 위임받은 제어 권한을 갖는 특별한 오브젝트에 의해 결정되고 만들어진다


93p

- 라이브러리 VS 프레임워크

    라이브러리는 필요한 기능을 미리 만들어둔 것

    프레임워크는 ?

    라이브러리를 사용하는 애플리케이션 코드는 애플리케이션 흐름을 직접 제어한다

    프레임워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다. 프레임워크가 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식이다


95p

- 빈 팩토리

    빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트

- 애플리케이션 컨텍스트

    빈 팩토리를 더 확장한 것, 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다


96p

- `@Configuration`

    애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시

- `@Bean`

    오브젝트 생성을 담당하는 IoC용 메소드라는 표시


102p

- 애플리케이션 컨텍스트 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용된다

    왜 여러 개가 만들어져야 하는가?


서비스 오브젝트

클라이언트 오브젝트의 요청을 처리하는 오브젝트

(DDD start 171p) DDD에서 응용 서비스의 역할은 도메인 객체를 사용해서 **사용자의 요청을 처리하는 것**



서블릿

자바 기반 서버에서 동작하는 프로그램

사용자 요청에 대한 기능을 제공한다

자바 클래스이며, 다양한 형태로 구현되어 쓰인다

HttpServlet, DispatherServlet 등



108p

서버에서 클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있다



111p

- 스프링 빈의 스코프

    singleton, prototype, request, session


117p

- DI

    자신이 사용할 오브젝트에 대한 선택과 생성 제어권을 외부로 넘기고 자신은 수동적으로 주입받은 오브젝트를 사용한다


127p

- DI 종류

    field injection



    constructor injection

    생성자 주입을 통해 생성된 객체는 유효한 상태를 보장한다

    클라이언트 오브젝트에서 서비스 오브젝트(여기서는 생성자 주입을 사용하는 객체)를 사용하려면 서비스 오브젝트를 생성해야하고, 서비스 오브젝트를 생성하려면 생성자에 의존관계에 해당하는 객체를 주입해야 하기 때문이다



    setter injection

    생성자 주입에서 생성자의 인자가 많아지면 다루기 쉽지 않다

    한 번 구성된 객체를 변경할 수 없다. 객체가 생성될 때 모든 주입에 관한 것이 결정되기 때문에.

    따라서 스프링의 경우 setter injection을 추천한다



    [https://blog.outsider.ne.kr/753](https://blog.outsider.ne.kr/753)

    > 생성자 기반의 DI냐? setter 기반의 DI냐?
    >
    > 생성자 기반 DI와 Setter 기반 DI를 섞어서 사용할 수 있으므로 경험에 의하면 강제적인 의존성은 생성자 아규먼트를 사용하고 선택적인 의존성은 setter를 사용하는 것이 좋다. setter에 @Required 어노테이션을 사용해서 의존성이 꼭 필요한 setter를 만들 수 있다.
    >
    > 스프링 팀은 보통 setter 주입을 더 좋아한다. 왜냐하면, 생성자 아규먼트가 많아지면 다루기가 쉽지 않기 때문이다. 특히 프로퍼티가 선택적이면 더욱 다루기가 어렵다. setter 메서드는 나중에 다시 설정하거나 다시 주입해야 하는 클래스의 객체들을 만들 수도 있다. JMX MBean을 통한 관리는 강제적인 유즈케이스이다.
    >
    > 몇몇 순수주의자들은 생성자 기반의 주입을 좋아한다. 모든 객체의 의존성을 제공한다는 것은 객체가 항상 클라이언트한테 완전히 초기화된 상태를 리턴한다는 것을 의미한다. 이 방법은 단점은 객체가 재구성이나 재주입하기가 쉽지 않아진다는 것이다.
    >
    > 개별 클래스에 적절한 DI를 사용해라. 때때로 소스코드가 없는 서드파티 클래스를 다룰 때는 어떤 DI를 사용할 지 직접 선택해야 한다. 레거시 클래스는 어떤 setter 메서드도 제공하지 않을 수 있으므로 생성자 주입이 이용 가능한 유일한 DI일 것이다.
