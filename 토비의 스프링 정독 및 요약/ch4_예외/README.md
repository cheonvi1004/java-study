# 토비의 스프링 챕터 4 예외

* 언제 checked, unckecked 예외를 쓰는가?
  * checked : 일반적인 예외, 애플리케이션 로직상에서 예외조건이 발견되거나 예외상황이 발생할 때 checked 예외를 던진다
  * unckecked : 시스템 장애나 프로그램상의 오류
* Spring에서는 어느 방식을 선호하며 그 이유는 무엇인가?

#### 잘못된 예외처리

``` java
try {
  // execute sql
} catch (SQLException e) {
  // do nothing
}
```

* 위 코드에서는 예외를 잡고서는 아무것도 하지 않는다. 예외 발생을 무시해버리고 정상적인 상황인 것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있는 게 아니라면 연습 중에도 절대 만들어서는 안 되는 코드다

``` java
} catch (SQLException e) {
  System.out.println(e);
}
```

``` java
} catch (SQLException e) {
  e.printStackTrace();
}
```

* catch 블록을 이용해 화면에 메시지를 출력한 것은 예외를 처리한 게 아니다
* 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 한다(throw new Exception(e))

#### Runtime Exception

* 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다

#### 예외처리 방법

* 예외복구
  * 예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도해주는 것

* 예외처리 회피
  * 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는 것
  * 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 있어야 한다

* 예외전환
  * 예외회피와는 달리 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다
  * 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도
    * 구현체별로 비슷한 의도를 가진 예외를 하나의 추상화된 예외보 감싸는 것
  * 중첩 예외(nested exception) 사용하기
    * 왜?
  * 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap)하기
    * 주로 ckecked 예외를 unchecked 예외로 만들기 위해 사용한다


#### 애플리케이션 예외

* 애플리케이션 자체 로직에 의해 의도적으로 발생시키고, 반ㅂ드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외
* 예외상황에서 비즈니스적인 의미를 띈 예외를 던지도록 만드는 것
  * 잔고부족일 경우 InsufficientBalanceException을 던지게 만드는 것

#### 낙관적인 락킹(Optimistic locking)

* 서로 다른 명령(?)이 동일한 데이터에 접근한 뒤 해당 데이터를 업데이트 하려 할 때, 앞에서 이미 데이터를 변경해버렸다면 뒤늦게 업데이트 명령을 내린 것은 변경된 데이터를 읽어서 업데이트를 다시 시도한다